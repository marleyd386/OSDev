#include <stdint.h>
#include "console.h"
#include "v86.h"

#define IOPL_LEVEL 0           /* IO privilege level = 0 restricted ring 3
                                  IF (Interrupt Flag) sensitive instructions fault */

#define REALMODE_CODE_SEG     0x0000
#define REALMODE_STACK_SEG    0x0000
#define REALMODE_STACK_OFFSET 0x0000

extern void v86main (void);

/* You can get this structure from GRUB's multiboot.h if needed
 * https://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot_002eh.html
 */
struct multiboot_info;

/* Values made available by the linker script */
extern void *__realmode_lma_start;
extern void *__realmode_lma_end;
extern void *__realmode_vma_start;

/* Copy the code and data in the realmode section down into the lower
 * 64kb of memory @ 0x00001000. */
void realmode_setup (void)
{
    /* Each of these __realmode* values is generated by the linker script */
    uint32_t *src_addr = (uint32_t *)&__realmode_lma_start;
    uint32_t *dst_addr = (uint32_t *)&__realmode_vma_start;
    uint32_t *src_end  = (uint32_t *)&__realmode_lma_end;

    /* Copy a DWORD at a time from source to destination */
    while (src_addr < src_end)
        *dst_addr++ = *src_addr++;
}

int kmain(struct multiboot_info *mb_info, const uint32_t magicnum)
{
    /* Quiet compiler about unused variables */
    (void) mb_info;
    (void) magicnum;
    uint32_t v86flags = IOPL_LEVEL<<EFLAGS_IOPL_BITS;

    clear_screen ();
    print_str_attr ("[Entering v8086 mode]\n", ATTR_BWHITE_ON_GREEN);
    enter_v86 (REALMODE_CODE_SEG, (uint16_t)(uint32_t)v86main,
               REALMODE_STACK_SEG, REALMODE_STACK_OFFSET, v86flags);
    print_str_attr ("[Exited v8086 mode]\n", ATTR_BWHITE_ON_GREEN);

    return 0;
}
